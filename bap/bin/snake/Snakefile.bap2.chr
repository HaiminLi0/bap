import os
import subprocess
import shutil
import re
import pysam

from os.path import join
from collections import Counter

configfile: config["cfp"]     
outdir = config["output"]
script_dir = config["script_dir"]          
R = config["R"] 
name = config["name"] 
output = config["output"] 
bead_tag = config["bead_tag"] 
drop_tag = config["drop_tag"] 

# Relevant thresholds
minimum_barcode_fragments = config["minimum_barcode_fragments"]
minimum_jaccard_index = str(config["minimum_jaccard_index"])
nc_threshold = str(config["nc_threshold"])

one_to_one = str(config["one_to_one"])
barcoded_tn5 = str(config["barcoded_tn5"])
barcode_whitelist = str(config["barcode_whitelist"])
blacklistRegionsFile = str(config["blacklistFile"])
barcodeQuantFile =  outdir + "/final/" + name + ".barcodequants.csv"

# Determine .bam files to execute for fragment overlap analysis
infile_nuclear = outdir + "/.internal/samples/" + name + ".chrbam.txt"
with open(infile_nuclear) as f:
    SAMPLES = f.readlines()
SAMPLES = [x.strip() for x in SAMPLES]

with open(outdir + "/.internal/samples/" + name + ".mitochrbam.txt") as f:
	mito_sample = f.readlines()
mito_sample = [x.strip() for x in mito_sample]

# Merge mito to the others
SAMPLES_noMito = SAMPLES
SAMPLES = SAMPLES + mito_sample

rdsin = [re.sub(".raw.bam$", "_overlapCount.rds", x.replace("/filt_split/", "/frag_overlap/")) for x in SAMPLES]
simple = [re.sub(".raw.bam$", "", x.replace(output + "/temp/filt_split/", "")) for x in SAMPLES]
chrOut = [x.replace("/filt_split/", "/drop_barcode/") for x in SAMPLES]
all_bead_counts = [output + "/temp/filt_split/" + x + ".bead_counts.tsv" for x in simple]

# Filepaths to executable scripts
knee_call_R = script_dir + "/bin/R/10b_knee_execute.R"
annotate_fragments_R = script_dir + "/bin/R/21_annotate_fragments.R"
fragOverlapChr_R = script_dir + "/bin/R/22_fragOverlapMetricsChr_bap2.R"
determineDoubles_R = script_dir + "/bin/R/23_callDoublets_bap2.R"


rule all:
	input:
		outdir + "/final/"+name+".bap.bam.bai"

rule assemble_fragments:
	input:
		rawbam = output + "/temp/filt_split/" + "{name}" + ".raw.bam"
	output:
		outbedpe = output + "/temp/filt_split/" + "{name}" + ".frag.bedpe.gz",
		outlog = output + "/logs/frag/" + "{name}" + ".bedtools.txt"
	threads:
		1
	run:
		namesort_bam = input.rawbam.replace(".raw.bam", "_nameSorted.bam")
		pysam.sort(input.rawbam, '-n','-o', namesort_bam, catch_stdout=False)
		l1 = "(bedtools bamtobed -i "+ namesort_bam
		l2 = ''' -bedpe | awk -v OFS="\t" '{if($9=="+"){print $1,$2+4,$6+4,$7}else if($9=="-"){print $1,$2-5,$6-5,$7}}' | gzip > ''' 
		l3 = output.outbedpe + ") 2> " + output.outlog
		call_frag_gen = l1 + l2 + l3
		os.system(call_frag_gen)


# here, the blacklist is enforced
rule annotate_fragments:
	input:
		inbedpe = output + "/temp/filt_split/" + "{name}" + ".frag.bedpe.gz"
	output:
		outbedpe = output + "/temp/filt_split/" + "{name}" + ".frag.bedpe.annotated.tsv.gz",
		outbeadcounts = output + "/temp/filt_split/" + "{name}" + ".bead_counts.tsv"
	threads:
		1
	run:
		read_bead_file = input.inbedpe.replace(".frag.bedpe.gz", ".read_bead.tsv.gz")
		temp_anno_bedpe = output.outbedpe.replace(".gz", "")
		r_call1 = " ".join([R+"script", annotate_fragments_R, blacklistRegionsFile, input.inbedpe, read_bead_file, temp_anno_bedpe, output.outbeadcounts])
		os.system(r_call1)
		os.system("gzip " + temp_anno_bedpe)



rule determine_HQ_beads:
	input:
		all_bead_counts 
	output:
		forKnee = outdir + "/knee/" + name + "barcodeQuantsSimple.csv",
		bapParams = outdir + "/knee/" + name + ".bapParams.csv",
		HQbeads = outdir + "/final/" + name + ".HQbeads.tsv"
	run:
		
		# Pool together per-chromosome fragment counts
		temp_file_1 = outdir + "/temp/filt_split/" + name + "_tempCounts.tsv" 
		for f in all_bead_counts:
			os.system("cat "+f+" >> " + temp_file_1)
		awk_call = '''awk '{ s[$1] += $2} END { for (i in s) { print i","s[i]} }' ''' + temp_file_1 + " > " + output.forKnee
		os.system(awk_call)
		
		# Import the unique barcodes quants
		
		# Call a knee on the resulting fragment abundances, if necessary
		knownBarcodes = False
		
		# Here, not necessary-- user has pre-specified barcodes
		if(os.path.isfile(barcode_whitelist)):
			knownBarcodes = True
			preDeterminedBarcodes =[line.rstrip('\n') for line in open(barcode_whitelist)]
			with open(output.bapParams, "w") as paramsFile:
				paramsFile.write("bead_threshold,predetermined\n")
		
		# Here, necessary-- perform a knee call
		elif(minimum_barcode_fragments == 0):		
			R_call_knee = R + "script " + knee_call_R + " " + output.forKnee + " 1 V2"
			os.system(R_call_knee)
			with open(output.forKnee + "_kneeValue.txt") as knee_open:
				minFrag = float(knee_open.readline().strip())
				callFrag = float(knee_open.readline().strip())
			with open(output.bapParams, "w") as paramsFile:
				paramsFile.write("bead_threshold_nosafety,"+str(callFrag)+"\n")
				paramsFile.write("bead_threshold,"+str(minFrag)+"\n")
		
		# Here, not necessary-- user has specified a custom hard cutoff
		else:
			with open(output.bapParams, "w") as paramsFile:
				paramsFile.write("bead_threshold,"+str(minimum_barcode_fragments)+"\n")
			minFrag = minimum_barcode_fragments
		
		# Irrespective of choice, define the set of high-quality bead barcodes, bc
		unique_barcodes = Counter()
		with open(output.forKnee) as bc_in_count:
			for line in bc_in_count:
				(key, val) = line.split(",")
				unique_barcodes[key] += int(val)
		
		if(knownBarcodes):
			barcodes = {x : unique_barcodes[x] for x in unique_barcodes if x in preDeterminedBarcodes}
		else:
			barcodes = {x : unique_barcodes[x] for x in unique_barcodes if unique_barcodes[x] >= minFrag and x != "NA"}
		bc = list(barcodes.keys())
		with open(output.HQbeads, 'w') as bc_file:
			for i in bc:
				bc_file.write(i+"\n")
		
rule compute_bap_stat_chr:
	input:
		HQbeads = outdir + "/final/" + name + ".HQbeads.tsv",
		annobedpe = output + "/temp/filt_split/" + "{name}" + ".frag.bedpe.annotated.tsv.gz"
	output:
		fragrds = output + "/temp/frag_overlap/" + "{name}" + "_overlapCount.rds",
		nc_count = output + "/temp/frag_overlap/" + "{name}" + "_ncCount.tsv"
	run:
		R_call_frag = R + "script " + fragOverlapChr_R + " " + nc_threshold + " " + input.HQbeads + " " + input.annobedpe + " "
		R_call_frag = R_call_frag + output.fragrds + " " + output.nc_count
		os.system(R_call_frag)

# Collate everything including NCs and bead merges; call knee if needed
rule determine_barcode_merges:
	input:
		rdsin = rdsin,
		forKnee = outdir + "/knee/" + name + "barcodeQuantsSimple.csv",
		HQbeads = outdir + "/final/" + name + ".HQbeads.tsv"
	output:
		outcsv = outdir + "/final/"+name+".implicatedBarcodes.csv.gz",
		outtsv = outdir + "/final/"+name+".barcodeTranslate.tsv",
		outNCtsv = outdir + "/final/"+name+".NCsumstats.tsv"
	run: 	
		# collate chr inference and make a single file
		rdsdir = outdir + "/temp/frag_overlap"
		r_call_findDoublets = " ".join([R+"script", determineDoubles_R, rdsdir, input.forKnee, input.HQbeads, output.outcsv, minimum_jaccard_index, name, one_to_one, barcoded_tn5])
		os.system(r_call_findDoublets)


rule temp_out:
	input:
		outtsv = outdir + "/final/"+name+".barcodeTranslate.tsv"
	output:
		finalout = outdir + "/final/"+name+".bap.bam.bai"
	run:
		os.system("touch " + output.finalout)